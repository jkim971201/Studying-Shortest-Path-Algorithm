#include <iostream>
#include <string>
#include <stdio.h>
#include <queue>
#include <unordered_set>

#include "Painter.h"
#include "Grid.h"

using namespace gui;

inline bool ifExist(std::unordered_set<int> visited, int val)
{
	if(visited.count(val) == 0)
		return false;
	else 
		return true;
}

class AStar
{
  public:

    AStar(const Grid* grid)
      : grid_ (grid)
    {}

		std::vector<Point> run();

  private:

    std::priority_queue<Node*> queue_;
    const Grid* grid_;
};

std::vector<Point> 
AStar::run()
{
	std::vector<Point> path;

	int lx = 0;
	int ly = 0;
	int ux = grid_->width() - 1;
	int uy = grid_->height() - 1;

	float costG = 0.0;
	int curX = grid_->start().x;
	int curY = grid_->start().y;

	int goalX = grid_->xT();
	int goalY = grid_->yT();

	Point curPoint(curX, curY);
	Node start( curX, curY, costG, grid_->getHeuristicCost(curPoint) );
	queue_.push( &start );

	int iter = 0;
	int maxIter = 100;
	
	std::unordered_set<int> visitedX;
	std::unordered_set<int> visitedY;
	visitedX.insert(curX);
	visitedY.insert(curY);

	while(!queue_.empty() && iter < maxIter)
	{
		Node* curNode = queue_.top();
		queue_.pop();
		iter += 1;
	
		curPoint = Point(curNode->x, curNode->y);

		printf("Iter[%03d] Cur : (%d, %d)\n", iter, curNode->x, curNode->y);

		path.push_back(curPoint);

		if(curPoint.x == goalX && curPoint.y == goalY)
			break;

		// Up
		if(curPoint.y + 1 <= uy )
		{
			Point newPoint(curPoint.x, curPoint.y + 1);
			float newG = curNode->costG + grid_->getCost(curPoint, newPoint);
			float newH = grid_->getHeuristicCost(newPoint);

			queue_.push( new Node(newPoint.x, newPoint.y, newG, newG + newH) );
			printf("  Iter[%03d] Push Up (%d, %d) f : %f\n", iter, newPoint.x, newPoint.y, newG + newH);
		}

		// Down
		if(curPoint.y - 1 >= ly)
		{
			Point newPoint(curPoint.x, curPoint.y - 1);
			float newG = curNode->costG + grid_->getCost(curPoint, newPoint);
			float newH = grid_->getHeuristicCost(newPoint);

			queue_.push( new Node(newPoint.x, newPoint.y, newG, newG + newH) );
			printf("  Iter[%03d] Push Down (%d, %d) f : %f\n", iter, newPoint.x, newPoint.y, newG + newH);
		}

		// Right
		if(curPoint.x + 1 <= ux)
		{
			Point newPoint(curPoint.x + 1, curPoint.y);
			float newG = curNode->costG + grid_->getCost(curPoint, newPoint);
			float newH = grid_->getHeuristicCost(newPoint);

			queue_.push( new Node(newPoint.x, newPoint.y, newG, newG + newH) );
			printf("  Iter[%03d] Push Right (%d, %d) f : %f\n", iter, newPoint.x, newPoint.y, newG + newH);
		}

		// Left 
		if(curPoint.x - 1 >= lx)
		{
			Point newPoint(curPoint.x - 1, curPoint.y);
			float newG = curNode->costG + grid_->getCost(curPoint, newPoint);
			float newH = grid_->getHeuristicCost(newPoint);

			queue_.push( new Node(newPoint.x, newPoint.y, newG, newG + newH) );
			printf("  Iter[%03d] Push Left (%d, %d) f : %f\n", iter, newPoint.x, newPoint.y, newG + newH);
		}
	}

	return path;
}

int main(int argc, char* argv[]) 
{
  int width  = 32;
  int height = 32;

  int startX = 0;
  int startY = 0;

  int endX = width - 1;
  int endY = height - 1;

	Point start(startX, startY);
	Point end(endX, endY);

  Grid grid(width, height, start, end);

	AStar algo(&grid);
	algo.run();

  QApplication app(argc, argv);
  Painter vis(&app, &grid);
  vis.openWindow();

  return 0;
}
